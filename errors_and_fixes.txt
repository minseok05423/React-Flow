ERRORS AND FIXES
================

1. TypeScript Error: Could not find declaration file for '@xyflow/react'
   Error: 'c:/Users/Mini/OneDrive/문서/dev/study/cs_journey/react/react-libraries/React-Flow/node_modules/@xyflow/react/dist/esm/index.js' implicitly has an 'any' type.

   Cause: TypeScript declaration files were missing from the installed package.

   Fix: Reinstalled node_modules to get the proper TypeScript declaration files:
   ```
   rm -rf node_modules && npm install
   ```
   Then restarted TypeScript server in VS Code.

2. Tailwind Dynamic Classes Not Working
   Error: Dynamic Tailwind classes like `bg-[${data.color}]` not rendering correctly.

   Cause: Tailwind CSS doesn't recognize dynamic classes at build time due to purging.

   Fix: Used inline styles instead:
   ```jsx
   // Before (not working)
   <div className={`bg-[${data.color}]`}>{data.value}</div>

   // After (working)
   <div style={{ backgroundColor: data.color }}>{data.value}</div>
   ```

3. React State Update Pattern
   Issue: How to update a specific object in an array without removing and re-adding it.

   Solution: Use map() with spread operator for immutable updates:
   ```jsx
   setNodes(prev => prev.map(node =>
     node.id === '1'
       ? { ...node, data: { ...node.data, color: 'red' } }
       : node
   ))
   ```
   This pattern preserves all existing properties while only updating what's needed.

4. State Updates Inside State Callbacks Causing Unexpected Behavior
   Issue: Calling setState inside another setState callback caused position to increment by 200 instead of 100.

   Cause: Stale closure - the currPosition value gets captured when the function is created, and calling setCurrPosition inside setNodes callback creates timing issues.

   Fix: Move state updates outside of other state callbacks:
   ```jsx
   // Before (problematic)
   function HandleClick() {
     setNodes((prev) => {
       const newNode = { position: { x: currPosition, y: 0 } };
       setCurrPosition((prev) => (prev += 100)); // Inside callback
       return [...prev, newNode];
     });
   }

   // After (working)
   function HandleClick() {
     setNodes((prev) => {
       const newNode = { position: { x: currPosition, y: 0 } };
       return [...prev, newNode];
     });
     setCurrPosition(prev => prev + 100); // Outside callback
   }
   ```

5. React StrictMode Double Console Logs
   Issue: console.log() statements appearing twice in development.

   Cause: React.StrictMode intentionally double-renders components in development to help detect side effects.

   Solution: This is expected behavior in development. It only happens in dev mode, not production. Keep StrictMode enabled as it helps catch bugs.

6. AddNode function bug:
   ERROR:
   ```
   function AddNode() {
     setNodes((prev) => {
       lastNodePos = prev.pop()?.position;
       // ... rest of code
     });
   }
   ```

   ISSUE: Using pop() mutates the prev array by removing the last element,
   then spreading [...prev, newNode] adds to the already-modified array,
   causing the original last node to disappear.

   FIX:
   ```
   function AddNode() {
     setNodes((prev) => {
       const lastNodePos = prev[prev.length - 1]?.position;
       const newNode = {
         id: `${prev.length + 1}`,
         position: { ...lastNodePos, x: (lastNodePos?.x || 0) + 200 },
         data: { value: "test node", color: "#D9E9CF" },
         type: "testNode",
       };
       return [...prev, newNode];
     });
   }
   ```

7. DeleteNode function bug:
   ERROR:
   ```
   function DeleteNode() {
     setNodes((prev) =>
       prev.length !== 0 ?
       prev.pop() : prev;
     );
   }
   ```

   ISSUE: pop() modifies the original array and returns the removed element,
   not the modified array. This returns the popped element instead of the
   updated nodes array, breaking React state updates.

   FIX:
   ```
   function DeleteNode() {
     setNodes((prev) => {
       if (prev.length === 0) return prev;
       const newNodes = [...prev];
       newNodes.pop();
       return newNodes;
     });
   }
   ```

   OR use slice():
   ```
   function DeleteNode() {
     setNodes((prev) =>
       prev.length !== 0 ?
       prev.slice(0, -1) : prev
     );
   }
   ```

8. useReactFlow hook usage error:
   ERROR:
   ```
   const { fitView } = useReactFlow;

   function Workflow() {
     // component code
   }
   ```

   ISSUE: useReactFlow is a React hook that must be called inside a component,
   not destructured outside of it. React hooks can only be used inside React
   components or other custom hooks.

   FIX:
   ```
   function Workflow() {
     const { fitView } = useReactFlow();
     // component code
   }
   ```

9. useEffect with Promise return error:
   ERROR:
   ```
   useEffect(() => fitView(), [nodes.length, fitView]);
   ```

   ISSUE: fitView() returns a Promise, and when using arrow function without
   brackets, the Promise gets implicitly returned from useEffect. React expects
   useEffect to return either undefined or a cleanup function, not a Promise.

   FIX:
   ```
   useEffect(() => {
     fitView();
   }, [nodes.length, fitView]);
   ```

   EXPLANATION: The brackets {} create a function body where fitView() is
   executed as a statement (not returned), so useEffect returns undefined
   instead of the Promise.

10. TypeScript array type syntax error:
    ERROR:
    ```
    function AddNodeLayer(refNode: Node, nodeLayer: []{value: string, color: string}) {
    ```

    ISSUE: Incorrect TypeScript syntax for array types. The [] should come
    after the type definition, not before it.

    FIX:
    ```
    function AddNodeLayer(refNode: Node, nodeLayer: {value: string, color: string}[]) {
    ```

    EXPLANATION: TypeScript array syntax is Type[] or Array<Type>, not []Type.

11. Object property mismatch error:
    ERROR:
    ```
    const sampleLayer = [{"a"}, {"b"}, {"c"}];
    // Used with function expecting: { value: string }[]
    ```

    ISSUE: Function expects objects with 'value' property, but array contains
    objects with different property names ("a", "b", "c").

    FIX:
    ```
    const sampleLayer = [{ value: "a" }, { value: "b" }, { value: "c" }];
    ```

    EXPLANATION: Object structure must match the TypeScript interface definition.

12. React Context naming conflict and type mismatch error:
    ERROR:
    ```
    import { nodeContext } from "./context/NodeContext";
    const [nodeContext, setNodeContext] = useState<{...}>({});
    <nodeContext.Provider value={{ nodeContext, setNodeContext }}>
    ```

    ISSUES:
    1. Variable name conflict between imported context and state variable
    2. Type mismatch - context expects { nodeInfo: {}, setNodeInfo: (info: {}) => void }
    3. Complex typing making code hard to understand

    FIX:
    ```
    import { nodeContext } from "./context/NodeContext";
    const [context, setContext] = useState({ nodeInfo: {} });
    <nodeContext.Provider
      value={{
        nodeInfo: context.nodeInfo,
        setNodeInfo: (info) => setContext({ nodeInfo: info }),
      }}
    >
    ```

    EXPLANATION:
    - Rename state variable to avoid naming conflict
    - Remove complex TypeScript types for simplicity
    - Match context interface by passing nodeInfo and setNodeInfo properties
    - Create wrapper function to transform setContext signature

13. Context Provider variable name mismatch error:
    ERROR:
    ```
    const [context, setContext] = useState({});
    <nodeContext.Provider
      value={{
        nodeInfo,      // undefined variable
        setNodeInfo,   // undefined variable
      }}
    >
    ```

    ISSUE: Provider value references variables (nodeInfo, setNodeInfo) that don't exist.
    The actual state variables are named context and setContext.

    FIX:
    ```
    const [context, setContext] = useState({});
    <nodeContext.Provider
      value={{
        nodeInfo: context,        // Pass context as nodeInfo
        setNodeInfo: setContext,  // Pass setContext as setNodeInfo
      }}
    >
    ```

    EXPLANATION: The Provider value object must use the actual variable names
    from your state, not the expected property names from the context interface.

14. React Context default value type confusion:
    ERROR:
    ```
    export const nodeContext = createContext<{
      nodeInfo: TreeNode[];
      setNodeInfo: (info: TreeNode[]) => void;
    }>([]);  // Trying to use empty array as default
    ```

    ISSUE: Context expects an object with nodeInfo and setNodeInfo properties,
    but an empty array [] was provided as the default value.

    WHY NULL IS USED:
    - Type mismatch: Context expects {nodeInfo, setNodeInfo} object, not array
    - Missing function: [] doesn't have setNodeInfo method
    - Forces Provider usage: null ensures components are wrapped in Provider
    - Prevents silent bugs: Throws clear error if used outside Provider

    CORRECT OPTIONS:
    ```
    // Option 1: Use null (recommended)
    export const nodeContext = createContext<{
      nodeInfo: TreeNode[];
      setNodeInfo: (info: TreeNode[]) => void;
    } | null>(null);

    // Option 2: Provide full default object
    export const nodeContext = createContext<{
      nodeInfo: TreeNode[];
      setNodeInfo: (info: TreeNode[]) => void;
    }>({
      nodeInfo: [],
      setNodeInfo: () => {}
    });
    ```

    EXPLANATION: null is preferred because it forces proper Provider usage
    and prevents accidental usage outside of the Provider context.

15. React StrictMode causing duplicate data due to state mutation:
    ERROR:
    ```
    setContext((prev) => {
      prev.push({ value: `${searchInput}`, children: null });
      return prev;
    });
    ```

    ISSUE: In StrictMode, React intentionally runs state setter functions twice
    to detect side effects. Using push() mutates the original array, so running
    twice adds the same data twice.

    CAUSE: Direct mutation of state object instead of creating new object.
    StrictMode double-execution reveals this side effect.

    DETAILED EXPLANATION:
    - React StrictMode deliberately executes state setters multiple times in development
    - This helps identify side effects and impure functions early
    - push() modifies the existing array reference instead of creating a new one
    - When React runs the setter again, it's operating on an already-modified array
    - This causes the new item to be added multiple times
    - React uses object reference equality to detect state changes
    - Mutating arrays doesn't change the reference, so React might not trigger re-renders
    - Always treat React state as immutable to avoid these issues

    FIX:
    ```
    // Option 1: Spread operator (recommended)
    setContext((prev) => [
      ...prev,
      { value: `${searchInput}`, children: null }
    ]);

    // Option 2: concat method
    setContext((prev) =>
      prev.concat({ value: `${searchInput}`, children: null })
    );
    ```

    WHY IMMUTABLE UPDATES WORK:
    - Creates a completely new array with each update
    - React can detect the reference change and trigger re-renders
    - Running the setter multiple times creates the same new array each time
    - No side effects from previous executions
    - Follows React's functional programming principles

    EXPLANATION: Immutable updates create new arrays instead of mutating existing ones.
    When run twice, they produce the same result. This is the correct React pattern
    and why StrictMode helps catch mutation bugs early.

16. TypeScript recursive function return type error:
    ERROR:
    ```
    Function implicitly has return type 'any' because it does not have a return
    type annotation and is referenced directly or indirectly in one of its return expressions.ts(7024)
    ```

    ISSUE: TypeScript cannot infer the return type of recursive functions because
    they reference themselves, creating a circular dependency in type inference.

    CAUSE: Missing explicit return type annotation on recursive function.

    EXAMPLE ERROR:
    ```
    function addChildrenToPath(tree, path, newChildren) {  // ❌ No return type
      // ... recursive calls
      return addChildrenToPath(node.children, path.slice(1), newChildren);
    }
    ```

    FIX:
    ```
    function addChildrenToPath(
      tree: TreeNode[],
      path: number[],
      newChildren: TreeNode[]
    ): TreeNode[] {  // ✅ Explicit return type
      // ... implementation
    }

    // Or with arrow function:
    const addChildrenToPath = (
      tree: TreeNode[],
      path: number[],
      newChildren: TreeNode[]
    ): TreeNode[] => {
      // ... implementation
    };
    ```

    EXPLANATION: TypeScript needs to know the return type before analyzing the
    function body. Recursive functions create circular references, so explicit
    return type annotations are required to break the inference cycle.

17. Array.map() missing return statement causing undefined elements:
    ISSUE: When using Array.map(), every element must return a value. Missing
    return statements for unmodified elements cause them to become undefined.

    EXAMPLE PROBLEM:
    ```
    const result = array.map(item => {
      if (shouldModify) {
        return modifiedItem;
      }
      // Missing return here - item becomes undefined
    });
    // Result: [modifiedItem, undefined, undefined, ...]
    ```

    CORRECT PATTERN:
    ```
    const result = array.map(item => {
      if (shouldModify) {
        return modifiedItem;  // Return modified version
      }
      return item;           // Return unchanged version
    });
    ```

    REAL EXAMPLE:
    ```
    return tree.map((node, index) => {
      if (index === path[0]) {
        return { ...node, children: [...] };  // Modified node
      }
      return node;  // Keep unchanged nodes
    });
    ```

    EXPLANATION: Array.map() creates a new array where each element is the
    return value of the callback function. If no value is returned for an
    element, it becomes undefined. Always return either the modified or
    original item to maintain array integrity.

18. React state update timing issue causing stale state access:
    ERROR:
    ```
    setContext([...context, { value: searchInput, children: [] }]);  // 1. Queue state update
    addNodes(rootNode);                                              // 2. Add visual node
    CreateLayer(rootNode);                                           // 3. Try to access context[0]

    // Inside CreateLayer:
    const newContext = AddChildrenToPath(context, path, childrenLayer);  // context is still []
    ```

    ISSUE: React state updates are asynchronous. When you call setState, the state
    variable doesn't update immediately. Functions that run right after setState
    still see the old state value.

    CAUSE: setState queues the update for the next render cycle, but subsequent
    code executes immediately with the current (stale) state values.

    SYMPTOMS:
    - Functions accessing state immediately after setState see old values
    - Array/object operations fail because expected data isn't there yet
    - "Cannot read property of undefined" errors when accessing nested state

    FIX:
    ```
    // Store the new state value in a local variable
    const newContext = [...context, { value: searchInput, children: [] }];  // 1. Create updated context
    setContext(newContext);                                                  // 2. Queue state update
    addNodes(rootNode);                                                      // 3. Add visual node
    CreateLayerWithContext(rootNode, newContext);                           // 4. Use updated context directly

    // Pass the fresh context to functions that need it
    function CreateLayerWithContext(refNode: Node, currentContext: TreeNode[]) {
      const newContext = AddChildrenToPath(currentContext, path, childrenLayer);  // Uses fresh context
      setContext(newContext);
    }
    ```

    EXPLANATION: By storing the updated state in a local variable before calling
    setState, you can immediately use the new value in subsequent operations.
    This avoids the timing issue where state updates are asynchronous but your
    code needs the updated value right away.